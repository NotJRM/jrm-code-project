#summary A random walk through code.
#labels Featured

= Introduction =

Here are various and sundry pieces of code with commentary.


= Details =

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/lispm.init lispm.init]
 My init file for the Lisp Machine.  Not especially interesting, but we have to begin somewhere.  The bobhack file gave me a mouse cursor that was J. R. "Bob" Dobbs with his pipe being the hot spot.  Unfortunately, that would cause occasional microcode crashes (something to do with the size of the bitmap).  I also had a cons cell mouse cursor and a middle finger cursor.  I started using a Dvorak keyboard at LMI.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/custom.lisp custom.lisp]
 Some customizations.  These are embarrassing.  Well, I was young.  I wouldn't use most of these now because it is important that other programmers can read your code.  These little name changes and hacks just add a layer of obfuscation.  I still think question marks are better than the trailing P however.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/pace/ Pace's files]
 Pace Willisson was one of best programmers I've ever worked with.  Here are some of his files.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/pace/disable-page-out-words.lisp disable-page-out-words.lisp]
 The LMI Lambda had a background process that would `scrub' dirty pages and write them back to disk.  It would also free the scrubbed pages, but that turned out to be a bad idea.  This hack that Pace wrote disables the freeing of the scrubbed pages.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/rg/ RG's files]
 [http://en.wikipedia.org/wiki/Richard_Greenblatt_(programmer) Rick Greenblatt] is one of the amazing people I have had the pleasure to work with.  We've had our differences over the years, but I have learned a lot from Rick.  Here are some of his files.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/rg/old-micro-tracer.lisp old-micro-tracer.lisp]
 When I started at LMI, Rick asked me to dust off the microcode tracer.  This was a program designed to check assertions in the Lambda microcode.  I played around with Rick's version for a while, but I found the code difficult to understand and wrote my own version.  The version here has a mixture of some code of mine with Rick's original code.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/m-p.lisp m-p.lisp]
  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/numsets.lisp numsets.lisp]
  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/uregs.lisp uregs.lisp]
  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/udasm.lisp udasm.lisp]
  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/jrm/utrace.lisp utrace.lisp]
 These files are parts of my version of the microcode tracer.  I started hitting the limitations of the LMI Lambda fairly quickly.  Closures didn't work right, lexical environments were limited to 64 variables, the garbage collector would crap out and halt the machine.  It was a nightmare.  Rick suggested that I simply fix the compiler and microcode.  So I became a compiler and microcode hacker.

  * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/sys/qcp1.lisp qcp1.lisp]
 The first problem was aliasing of lexical variables in parallel environments.  This turned out to be a thorny problem.  The `breakoff` function in qcp1 handles lexical closures.  Right after this function is a comment I wrote that explains the rather nasty solution.  We temporarily replace the lexical variables with GENSYMS to avoid the aliasing, but set them back when we do the recursive compile.  Some of the comments in this file are mine, but I forget which ones.

 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/closures.txt closures.txt]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/uc-stack-closure.lisp uc-stack-closure.lisp]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/lex-fix.txt lex-fix.txt]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/uc-closure.lisp uc-closure.lisp]
 The second problem turned out to be bugs in the microcode.  The original closure microcode was overly complicated and buggy.  I rewrote good chunks of it and finally rewrote the entire heap allocated closure routines.

 As it turned out, Pace and I discovered a fundamental problem in the stack closure implementation.  It was possible, under certain circumstances, to create a stack frame that contained pointers to dead structure that appeared to be stack closures.  An unlucky garbage collection at that point would trash the stack.  We couldn't figure out a viable solution to the problem, so we made the decision to simply allocate all closures in the heap.  At that time, we had enough confidence in the generational GC, so the decision was easy.

 Lowell Hawkinson, however, was not too happy about this.  The PICON group at LMI (which later broke off to start the [http://www.gensym.com/ GENSYM] corporation) was his pet project and he worked hard to ensure that the PICON program would do no consing whatsoever when it was running in a steady state.  Of course the implicit consing done by heap-allocation of closures threw a monkey wrench in that plan.  We pointed out that the choice was between consing and random, unpredictable crashing, and that the generational garbage collector actually worked, he grudgingly accepted it.
 
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/ Lambda Microcode]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ubin/ ubin]
 Here is the microcode to the LMI Lambda.  I did a bunch of tweaking and fixing here as you can see if you look at the ulambda-comments.txt file.  When I started using closures I became the major source of runtime garbage at LMI.  Most users simply turned of the garbage collector, wrote code that avoided consing, and rebooted once the machine ran out of memory.  I thought that the machine should be taking care of the garbage rather than me, so I got nominated to get the GC working.

 It turned out that there were few bugs in the GC that Ken Sinclair wrote.  The majority of `GC' bugs were errors in the rest of the runtime system that violated the invariants that were required by the GC.  This would cause random crashes when some invalid pointer caused the GC to trash part of the heap.  The bug wasn't caused by the GC, but we always blamed the messenger.  I spent the better part of year tracking these things down and became very familiar with all different parts of the microcode.  As an example, look at the ulambda-comments for late March to early April 1986.  It took me a week to find the bug in [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/uc-storage-allocation.lisp uc-storage-allocation.lisp] (look in x-make-array.  The fix is to put a NIL in m-d before returning).

 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/cold/ cold]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/debugger/ debugger]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/demo/ demo]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/dired-fsdebug/ dired-fsdebug]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/examples/ examples]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/file/ file]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/io/ io]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/io1/ io1]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/network/ network]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/sys/ sys]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/sys2/ sys2]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ubin/ ubin]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/ulambda/ ulambda]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/window/ window]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/zmail/ zmail]
 * [http://jrm-code-project.googlecode.com/svn/trunk/lambda/zwei/ zwei]
 These directories contain the basic Lisp Machine code.












